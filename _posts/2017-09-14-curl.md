---
layout: post
title:  "cURL"
date:   2017-09-14 12:02:30 -0400
categories: articles
---


# URL
##### __What is curl__
curl is a tool to transfer data from or to a server, using one of the supported protocols (HTTP, HTTPS, FTP, FTPS, SCP, SFTP, TFTP, DICT, TELNET, LDAP or FILE). The command is designed to work without user interaction. It offers proxy support, user authentication, FTP uploading, HTTP posting, SSL connections, cookies, file transfer resume, Metalink, and many other features, listed below.

#### __curl syntax__

```
curl [options] [URL...]
```

#### __Port number__

```
curl http://www.example.org:1234/

```

#### __User name and password__

```
curl http://user:password@example.org/
```
Or
```
curl -u user:password http://example.org/
```


# Fetch a page

#### __GET__

The simplest and most common request/operation made using HTTP is to GET a URL. The URL could itself refer to a web page, an image or a file. The client issues a GET request to the server and receives the document it asked for. If you issue the command line

 curl https://curl.haxx.se
you get a web page returned in your terminal window. The entire HTML document that that URL holds.

All HTTP replies contain a set of response headers that are normally hidden, use curl's --include (-i) option to display them as well as the rest of the document.


#### __HEAD__
You can ask the remote server for ONLY the headers by using the --head (-I) option which will make curl issue a HEAD request. In some special cases servers deny the HEAD method while others still work, which is a particular kind of annoyance.

The HEAD method is defined and made so that the server returns the headers exactly the way it would do for a GET, but without a body. It means that you may see a Content-Length: in the response headers, but there must not be an actual body in the HEAD response.

#### __Multi in One__
A single curl command line may involve one or many URLs. The most common case is probably to just use one, but you can specify any amount of URLs. Yes any. No limits. You'll then get requests repeated over and over for all the given URLs.

Example, send two GETs:

curl http://url1.example.com http://url2.example.com

If you use --data to POST to the URL, using multiple URLs means that you send that same POST to all the given URLs.

Example, send two POSTs:

curl --data name=curl http://url1.example.com http://url2.example.com


# HTML forms

#### __Forms explained__
Forms are the general way a web site can present a HTML page with fields for the user to enter data in, and then press some kind of 'OK' or 'Submit' button to get that data sent to the server. The server then typically uses the posted data to decide how to act. Like using the entered words to search in a database, or to add the info in a bug tracking system, display the entered address on a map or using the info as a login-prompt verifying that the user is allowed to see what it is about to see.

Of course there has to be some kind of program on the server end to receive the data you send. You cannot just invent something out of the air.

#### __GET__

A GET-form uses the method GET, as specified in HTML like:

```html
 <form method="GET" action="junk.cgi">
 <input type=text name="birthyear">
 <input type=submit name=press value="OK">
 </form>
```

In your favorite browser, this form will appear with a text box to fill in and a press-button labeled "OK". If you fill in '1905' and press the OK button, your browser will then create a new URL to get for you. The URL will get "junk.cgi?birthyear=1905&press=OK" appended to the path part of the previous URL.

If the original form was seen on the page "www.hotmail.com/when/birth.html", the second page you'll get will become "www.hotmail.com/when/junk.cgi?birthyear=1905&press=OK".

Most search engines work this way.

To make curl do the GET form post for you, just enter the expected created URL:

```
 curl "http://www.hotmail.com/when/junk.cgi?birthyear=1905&press=OK"
```



#### __POST__

The GET method makes all input field names get displayed in the URL field of your browser. That's generally a good thing when you want to be able to bookmark that page with your given data, but it is an obvious disadvantage if you entered secret information in one of the fields or if there are a large amount of fields creating a very long and unreadable URL.

_The HTTP protocol then offers the POST method. This way the client sends the data separated from the URL and thus you won't see any of it in the URL address field._

The form would look very similar to the previous one:

 <form method="POST" action="junk.cgi">
 <input type=text name="birthyear">
 <input type=submit name=press value=" OK ">
 </form>
And to use curl to post this form with the same data filled in as before, we could do it like:

 curl --data "birthyear=1905&press=%20OK%20"  http://www.example.com/when.cgi
This kind of POST will use the Content-Type application/x-www-form-urlencoded and is the most widely used POST kind.

The data you send to the server MUST already be properly encoded, curl will not do that for you. For example, if you want the data to contain a space, you need to replace that space with %20 etc. Failing to comply with this will most likely cause your data to be received wrongly and messed up.

Recent curl versions can in fact url-encode POST data for you, like this:

 curl --data-urlencode "name=I am Daniel" http://www.example.com
If you repeat --data several times on the command line, curl will concatenate all the given data pieces - and put a '&' symbol between each data segment.



#### __Hidden Fields__

A very common way for HTML based applications to pass state information between pages is to add hidden fields to the forms. Hidden fields are already filled in, they aren't displayed to the user and they get passed along just as all the other fields.

A similar example form with one visible field, one hidden field and one submit button could look like:

```html
<form method="POST" action="foobar.cgi">

 <input type=text name="birthyear">
 <input type=hidden name="person" value="daniel">
 <input type=submit name="press" value="OK">
</form>
```
To POST this with curl, you won't have to think about if the fields are hidden or not. To curl they're all the same:

 curl --data "birthyear=1905&press=OK&person=daniel" [URL]

# HTTP upload

#### __PUT__

Perhaps the best way to upload data to a HTTP server is to use PUT. Then again, this of course requires that someone put a program or script on the server end that knows how to receive a HTTP PUT stream.

Put a file to a HTTP server with curl:

 curl --upload-file uploadfile http://www.example.com/receive.cgi


# HTTP Authentication


#### __Basic Authentication__

HTTP Authentication is the ability to tell the server your username and password so that it can verify that you're allowed to do the request you're doing. The Basic authentication used in HTTP (which is the type curl uses by default) is *plain* *text* based, which means it sends username and password only slightly obfuscated, but still fully readable by anyone that sniffs on the network between you and the remote server.

To tell curl to use a user and password for authentication:

 curl --user name:password http://www.example.com

#### __Other Authentication__

The site might require a different authentication method (check the headers returned by the server), and then --ntlm, --digest, --negotiate or even --anyauth might be options that suit you.


#### __Proxy Authentication__

Sometimes your HTTP access is only available through the use of a HTTP proxy. This seems to be especially common at various companies. A HTTP proxy may require its own user and password to allow the client to get through to the Internet. To specify those with curl, run something like:

 curl --proxy-user proxyuser:proxypassword curl.haxx.se
If your proxy requires the authentication to be done using the NTLM method, use --proxy-ntlm, if it requires Digest use --proxy-digest.

If you use any one of these user+password options but leave out the password part, curl will prompt for the password interactively.


# Cookies

#### __Cookie Basics__

The way the web browsers do "client side state control" is by using cookies. Cookies are just names with associated contents. The cookies are sent to the client by the server. The server tells the client for what path and host name it wants the cookie sent back, and it also sends an expiration date and a few more properties.

When a client communicates with a server with a name and path as previously specified in a received cookie, the client sends back the cookies and their contents to the server, unless of course they are expired.

Many applications and servers use this method to connect a series of requests into a single logical session. To be able to use curl in such occasions, we must be able to record and send back cookies the way the web application expects them. The same way browsers deal with them.

#### __Cookie options__

The simplest way to send a few cookies to the server when getting a page with curl is to add them on the command line like:

 curl --cookie "name=Daniel" http://www.example.com
Cookies are sent as common HTTP headers. This is practical as it allows curl to record cookies simply by recording headers. Record cookies with curl by using the --dump-header (-D) option like:

 curl --dump-header headers_and_cookies http://www.example.com
(Take note that the --cookie-jar option described below is a better way to store cookies.)

Curl has a full blown cookie parsing engine built-in that comes in use if you want to reconnect to a server and use cookies that were stored from a previous connection (or hand-crafted manually to fool the server into believing you had a previous connection). To use previously stored cookies, you run curl like:

 curl --cookie stored_cookies_in_file http://www.example.com
Curl's "cookie engine" gets enabled when you use the --cookie option. If you only want curl to understand received cookies, use --cookie with a file that doesn't exist. Example, if you want to let curl understand cookies from a page and follow a location (and thus possibly send back cookies it received), you can invoke it like:

 curl --cookie nada --location http://www.example.com
Curl has the ability to read and write cookie files that use the same file format that Netscape and Mozilla once used. It is a convenient way to share cookies between scripts or invokes. The --cookie (-b) switch automatically detects if a given file is such a cookie file and parses it, and by using the --cookie-jar (-c) option you'll make curl write a new cookie file at the end of an operation:

 curl --cookie cookies.txt --cookie-jar newcookies.txt  http://www.example.com

# HTTPS

#### __HTTPS is HTTP secure__

There are a few ways to do secure HTTP transfers. By far the most common protocol for doing this is what is generally known as HTTPS, _HTTP over SSL_. SSL encrypts all the data that is sent and received over the network and thus makes it harder for attackers to spy on sensitive information.

SSL (or TLS as the latest version of the standard is called) offers a truckload of advanced features to allow all those encryptions and key infrastructure mechanisms encrypted HTTP requires.

Curl supports encrypted fetches when built to use a TLS library and it can be built to use one out of a fairly large set of libraries - "curl -V" will show which one your curl was built to use (if any!). To get a page from a HTTPS server, simply run curl like:

 curl https://secure.example.com


#### __Certificates__

In the HTTPS world, you use certificates to validate that you are the one you claim to be, as an addition to normal passwords. Curl supports client- side certificates. All certificates are locked with a pass phrase, which you need to enter before the certificate can be used by curl. The pass phrase can be specified on the command line or if not, entered interactively when curl queries for it. Use a certificate with curl on a HTTPS server like:

 curl --cert mycert.pem https://secure.example.com
curl also tries to verify that the server is who it claims to be, by verifying the server's certificate against a locally stored CA cert bundle. Failing the verification will cause curl to deny the connection. You must then use --insecure (-k) in case you want to tell curl to ignore that the server can't be verified.

More about server certificate verification and ca cert bundles can be read in the SSLCERTS document, available online here:

 https://curl.haxx.se/docs/sslcerts.html
At times you may end up with your own CA cert store and then you can tell curl to use that to verify the server's certificate:

 curl --cacert ca-bundle.pem https://example.com/


[More details](https://curl.haxx.se/docs/httpscripting.html)

[manual](https://curl.haxx.se/docs/manual.html)

[curl command](https://www.computerhope.com/unix/curl.htm)
